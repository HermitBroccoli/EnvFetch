# EnvUtil

**EnvUtil** - универсальная библиотека, разработанная для эффективного управления переменными окружения и конфигурациями в ваших проектах. Она предоставляет интуитивно понятные инструменты для создания, управления и плавного переключения между различными настройками окружения, что значительно упрощает процесс разработки.

С помощью `EnvUtil` вы легко сможете:

- Определять и управлять переменными окружения.
- Настраивать параметры подключения к различным сервисам и базам данных.
- Управлять настройками приложения в зависимости от текущего окружения (например, разработка, тестирование, продакшн).

Эта библиотека предлагает следующие преимущества:

- **Гибкость**: Легко адаптировать приложения к различным условиям работы без изменения кода.
- **Надежность**: Создание более надежных и масштабируемых приложений путем эффективного управления окружением с минимальными усилиями и максимальной эффективностью.

**EnvUtil** дает разработчикам возможность создавать устойчивые приложения, упрощая управление окружением и обеспечивая адаптацию к различным операционным контекстам без лишних сложностей.

# Использование EnvUtil

Для интеграции **EnvUtil** в ваш проект выполните следующие шаги:

1. **Установка библиотеки:**
   Установите `EnvUtil` через ваш менеджер пакетов. Например, если вы используете pip:

   PowerShell | CMD
   ```bash
   pip install envutil
   ```
   Linux
   ```bash
   pip3 install envutil
   ```

2. **Использование EnvUtil:**
   
   После установки библиотеки, вы можете создать экземпляр `EnvUtil` для управления вашими переменными окружения. Вот пример использования:

   ```python
    # Импортируем класс EnvUtil из библиотеки envutil
    from envutil import EnvUtil

    # Создаем экземпляр EnvUtil без явного указания пути к файлу .env
    # По умолчанию будет считываться файл .env из корня проекта
    env = EnvUtil()

    # Получаем значение переменной DP_HOST из файла .env и выводим его
    print(env.get_value("DP_HOST"))

   ```

   В этом примере `EnvUtil` создается без явного указания пути к файлу .env. По умолчанию, `EnvUtil` будет пытаться считать файл `.env` из корня проекта. Вы можете использовать метод get_value для извлечения значения конкретной переменной окружения, например, переменной `DP_HOST`.
   
   ---
   ```python
    from envutil import EnvUtil

    # По умолчанию мы считываем файл `.env` из корня проекта. Однако, если ваш файл `.env` хранится в другом месте,
    # вы можете создать переменную с путем к файлу:

    custom_env_file_path = "env\\.env"

    # Для использования файла `.env`, расположенного в другом месте, создайте экземпляр EnvUtil,
    # указав путь к файлу:

    env = EnvUtil(file_path=custom_env_file_path)

    # Этот пример показывает, как указать путь к файлу `.env` вне корня проекта при создании экземпляра EnvUtil.
    # Затем вы можете получить значения переменных окружения, например, значение переменной DP_HOST.
    print(env.get_value("DP_HOST"))

   ```
    В данном примере создается экземпляр `EnvUtil`, где указывается путь к файлу `.env` вне корня проекта. Это демонстрирует способ использования `EnvUtil` с пользовательским путем к файлу `.env`, который отличается от стандартного пути в корне проекта.

   ---   
   ```python
    # Можно также указать путь к файлу `.env` непосредственно при объявлении класса:

    from envutil import EnvUtil

    # При создании экземпляра EnvUtil сразу пропишем путь к файлу `.env` в его конструкторе:
    env = EnvUtil(file_path="env\\.env")

    # Этот код демонстрирует создание экземпляра EnvUtil с указанием пути к файлу `.env` внутри объявления класса.
    # Затем вы можете получить значения переменных окружения, например, значение переменной DP_HOST.
    print(env.get_value("DP_HOST"))

   ```

   В данном примере экземпляр `EnvUtil` создается с указанием пути к файлу `.env` прямо в конструкторе класса. Это позволяет сразу при создании экземпляра указывать путь к файлу `.env`, который будет использоваться для работы с переменными окружения.

3. **Значение по умолчанию:**

   В случае, если значение переменной окружения отсутствует или не установлено в файле `.env`, можно установить значение по умолчанию. Пример:

   ```python
   from envutil import EnvUtil

   # Создаем экземпляр EnvUtil без указания пути к файлу .env
   env = EnvUtil()

   # Получаем значение переменной, но если оно отсутствует, используем значение по умолчанию
   default_value = env.get_value("SOME_VARIABLE_NAME", default="DEFAULT_VALUE")
   print(default_value)
   ```

   Этот пример иллюстрирует способ использования `EnvUtil` для извлечения значения переменной `SOME_VARIABLE_NAME` из файла `.env`. В случае, если данная переменная отсутствует или не имеет значения, установленного в файле, будет использовано значение по умолчанию, указанное как `DEFAULT_VALUE`. Такой механизм предоставляет гибкость в работе с переменными окружения, позволяя задавать значения по умолчанию для обеспечения более предсказуемой работы приложения, даже если некоторые переменные не были установлены или не найдены в файле `.env`.

4. **Управление переменными окружения:**

   В настоящее время `EnvUtil` предоставляет возможности только для чтения значений переменных окружения из файла `.env`. Операции изменения или удаления переменных окружения непосредственно через `EnvUtil` не поддерживаются в текущей версии библиотеки.

   В будущих версиях планируется расширение функциональности для управления переменными окружения, включая добавление, изменение и удаление переменных. При появлении обновлений вам будет доступна возможность более активно взаимодействовать с переменными окружения с помощью `EnvUtil`.

5. **Использование переменных окружения в условиях:**

   Переменные окружения могут быть использованы для управления поведением вашего приложения в зависимости от среды исполнения или установленных настроек. Пример использования переменных окружения в условиях:

   ```python
   from envutil import EnvUtil

   # Создаем экземпляр EnvUtil для доступа к переменным окружения
   env = EnvUtil()

   # Проверяем наличие переменной и выполняем определенные действия, если она установлена
   if env.get_value("DEBUG_MODE") == "True":
       # Выполняем действия в режиме отладки
       print("Debug mode is enabled.")
   else:
       # Выполняем обычные действия
       print("Running in standard mode.")
    ```



   
